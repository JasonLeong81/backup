// Class ----------------------------------------------------------------------------------------------------------------------------------------
// using ConsoleApp1; // using the consoleapp1 namespace, but not using it here to avoid circular imports 
using System; 

namespace testing
{

    class Car
    {
        /*
        Modifier  : Description 
        public    :	The code is accessible for all classes
        private   :	The code is only accessible within the same class
        protected :	The code is accessible within the same class, or in a class that is inherited from that class. 
        internal  :	The code is only accessible within its own assembly, but not from another assembly. (An assembly is a file that is automatically generated by the compiler upon successful compilation of every . NET application.)

        There's also two combinations: protected internal and private protected. 

        The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from users. To achieve this: 
            - provide public get and set methods, through properties, to access and update the value of a private field
            - use private for fields

        Derived class are children and base class is parent, use : for inheritance. Use sealed keyword if we don't want other classes to inherit from a class. 

        Abstraction? -> abstract and override. abstract classes cannot create instance but can be inherited and abstract methods have no body. 
        Interface. interface class is a 100% abstract class. 
            - Interface members are by default abstract and public. 
            - Interfaces can contain properties and methods, but not fields/variables
            - An interface cannot contain a constructor (as it cannot be used to create objects)
            - C# does not support "multiple inheritance" (a class can only inherit from one base class). However, it can be achieved with interfaces, because the class can implement multiple interfaces. To implement multiple interfaces, separate them with a comma.
            - 

         */


        private string color = "red"; // a field // constructor overwrites, so color becomes string now 
        public Car(string c = "random")
        {
            // A constructor's name must be same as the class and cannot have any return type. 
            // Just like other methods, constructors can be overloaded by using different numbers of parameters.
            color = c;
        }
        // Console.WriteLine("testing"); // why doesn't this work? 
        public string t() // a method 
        {
            return "333333333333333333333333333333333333333333";
        }
        public string Name // a property: it has two methods (get and set) and we can access it like a variable 
        {
            get { return color; } // get method 
            set { color = value; } // The word "value" references the value that client code is attempting to assign to the property or indexer. // set method 
        }


    }

    class Blue : Car
    {
        // virtual and override?? 
        public string color = "blue";
        public string t() // a method 
        {
            return "555555555555555555555555555555555555555555";
        }
    }

    interface IFirstInterface
    {
        void myMethod(); // interface method
    }

    interface ISecondInterface
    {
        void myOtherMethod(); // interface method
    }

    class DemoClass : IFirstInterface, ISecondInterface
    {
        public void myMethod()
        {
            Console.WriteLine("Some text..");
        }
        public void myOtherMethod()
        {
            Console.WriteLine("Some other text...");
        }
    }
}